.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "WWW::WebKit 3"
.TH WWW::WebKit 3 "2019-03-31" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::WebKit \- Perl extension for controlling an embedding WebKit engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use WWW::WebKit;
\&
\&    my $webkit = WWW::WebKit\->new(xvfb => 1);
\&    $webkit\->init;
\&
\&    $webkit\->open("http://www.google.com");
\&    $webkit\->type("q", "hello world");
\&    $webkit\->click("btnG");
\&    $webkit\->wait_for_page_to_load(5000);
\&    print $webkit\->get_title;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
WWW::WebKit is a drop-in replacement for WWW::Selenium using Gtk3::WebKit as browser instead of relying on an external Java server and an installed browser.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
\fIconsole_messages\fR
.IX Subsection "console_messages"
.PP
WWW::WebKit saves console messages in this array but still lets the default console handler handle the message.
I'm not sure if this is the best way to go but you should be able to override this easily:
.PP
.Vb 5
\&    use Glib qw(TRUE FALSE);
\&    $webkit\->view\->signal_connect(\*(Aqconsole\-message\*(Aq => sub {
\&        push @{ $webkit\->console_messages }, $_[1];
\&        return TRUE;
\&    });
.Ve
.PP
The \s-1TRUE\s0 return value prevents any further handlers from kicking in which in turn should prevent any messages from getting printed.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
\fIinit\fR
.IX Subsection "init"
.PP
Initializes Webkit and \s-1GTK3.\s0 Must be called before any of the other methods.
.SS "Implemented methods of the Selenium \s-1API\s0"
.IX Subsection "Implemented methods of the Selenium API"
Please see WWW::Selenium for the full documentation of these methods.
.PP
\fIset_timeout($timeout)\fR
.IX Subsection "set_timeout($timeout)"
.PP
Set the default timeout to \f(CW$timeout\fR.
.PP
\fIopen($url)\fR
.IX Subsection "open($url)"
.PP
\fI\fIrefresh()\fI\fR
.IX Subsection "refresh()"
.PP
\fI\fIgo_back()\fI\fR
.IX Subsection "go_back()"
.PP
\fIget_xpath_count\fR
.IX Subsection "get_xpath_count"
.PP
\fIselect($select, \f(CI$option\fI)\fR
.IX Subsection "select($select, $option)"
.PP
\fIclick($locator)\fR
.IX Subsection "click($locator)"
.PP
\fIcheck($locator)\fR
.IX Subsection "check($locator)"
.PP
\fIuncheck($locator)\fR
.IX Subsection "uncheck($locator)"
.PP
\fIwait_for_page_to_load($timeout)\fR
.IX Subsection "wait_for_page_to_load($timeout)"
.PP
\fIwait_for_element_present($locator, \f(CI$timeout\fI)\fR
.IX Subsection "wait_for_element_present($locator, $timeout)"
.PP
\fIis_element_present($locator)\fR
.IX Subsection "is_element_present($locator)"
.PP
\fIget_text($locator)\fR
.IX Subsection "get_text($locator)"
.PP
\fItype($locator, \f(CI$text\fI)\fR
.IX Subsection "type($locator, $text)"
.PP
\fItype_keys($locator, \f(CI$string\fI)\fR
.IX Subsection "type_keys($locator, $string)"
.PP
\fIpause($time)\fR
.IX Subsection "pause($time)"
.PP
\fIis_ordered($first, \f(CI$second\fI)\fR
.IX Subsection "is_ordered($first, $second)"
.PP
\fI\fIget_body_text()\fI\fR
.IX Subsection "get_body_text()"
.PP
\fI\fIget_title()\fI\fR
.IX Subsection "get_title()"
.PP
\fImouse_over($locator)\fR
.IX Subsection "mouse_over($locator)"
.PP
\fImouse_down($locator)\fR
.IX Subsection "mouse_down($locator)"
.PP
\fImouse_up($locator)\fR
.IX Subsection "mouse_up($locator)"
.PP
\fIfire_mouse_event($locator, \f(CI$event_type\fI)\fR
.IX Subsection "fire_mouse_event($locator, $event_type)"
.PP
\fIfire_event($locator, \f(CI$event_type\fI)\fR
.IX Subsection "fire_event($locator, $event_type)"
.PP
\fIget_value($locator)\fR
.IX Subsection "get_value($locator)"
.PP
\fIget_attribute($locator)\fR
.IX Subsection "get_attribute($locator)"
.PP
\fIis_visible($locator)\fR
.IX Subsection "is_visible($locator)"
.PP
\fIsubmit($locator)\fR
.IX Subsection "submit($locator)"
.PP
\fI\fIget_html_source()\fI\fR
.IX Subsection "get_html_source()"
.PP
Returns the source code of the current \s-1HTML\s0 page as it was transferred over the network.
.PP
Use \f(CW$webkit\fR\->view\->get_dom_document\->get_document_element\->get_outer_html to get the serialized
current \s-1DOM\s0 tree (with all modifications by Javascript)
.PP
\fI\fIget_confirmation()\fI\fR
.IX Subsection "get_confirmation()"
.PP
\fI\fIget_alert()\fI\fR
.IX Subsection "get_alert()"
.PP
\fI\fIprint_requested()\fI\fR
.IX Subsection "print_requested()"
.PP
\fIanswer_on_next_confirm\fR
.IX Subsection "answer_on_next_confirm"
.PP
\fIanswer_on_next_prompt($answer)\fR
.IX Subsection "answer_on_next_prompt($answer)"
.SS "Additions to the Selenium \s-1API\s0"
.IX Subsection "Additions to the Selenium API"
\fIwait_for_pending_requests($timeout)\fR
.IX Subsection "wait_for_pending_requests($timeout)"
.PP
Waits for all pending requests to finish. This is most useful for \s-1AJAX\s0 applications,
since wait_for_page_to_load does not wait for \s-1AJAX\s0 requests.
.PP
\fIwait_for_element_to_disappear($locator, \f(CI$timeout\fI)\fR
.IX Subsection "wait_for_element_to_disappear($locator, $timeout)"
.PP
Works just like wait_for_element_present but instead of waiting for the element to appear, it waits for the element to disappear.
.PP
\fIwait_for_alert($text, \f(CI$timeout\fI)\fR
.IX Subsection "wait_for_alert($text, $timeout)"
.PP
Wait for an alert with the given text to happen.
If \f(CW$text\fR is undef, it waits for any alert. Since alerts do not get automatically cleared, this has to be done manually before causing the action that is supposed to throw a new alert:
.PP
.Vb 3
\&    $webkit\->alerts([]);
\&    $webkit\->click(\*(Aq...\*(Aq);
\&    $webkit\->wait_for_alert;
.Ve
.PP
\fIwait_for_condition($condition, \f(CI$timeout\fI)\fR
.IX Subsection "wait_for_condition($condition, $timeout)"
.PP
Wait for the given \f(CW$condition\fR sub to return a true value or \f(CW$timeout\fR to expire.
Returns the return value of \f(CW$condition\fR or 0 on timeout.
.PP
.Vb 3
\&    $webkit\->wait_for_condition(sub {
\&        $webkit\->is_visible(\*(Aqid=foo\*(Aq);
\&    }, 10000);
.Ve
.PP
\fInative_drag_and_drop_to_position($source_locator, \f(CI$target_x\fI, \f(CI$target_y\fI, \f(CI$options\fI)\fR
.IX Subsection "native_drag_and_drop_to_position($source_locator, $target_x, $target_y, $options)"
.PP
Drag source element and drop it to position \f(CW$target_x\fR, \f(CW$target_y\fR.
.PP
\fInative_drag_and_drop_to_object($source_locator, \f(CI$target_locator\fI, \f(CI$options\fI)\fR
.IX Subsection "native_drag_and_drop_to_object($source_locator, $target_locator, $options)"
.PP
Drag source element and drop it into target element.
.PP
\fI\fIdisable_plugins()\fI\fR
.IX Subsection "disable_plugins()"
.PP
Disables WebKit plugins. Use this if you don't need plugins like Java and Flash
and want to for example silence plugin loading messages.
.PP
\fIdelete_text($locator)\fR
.IX Subsection "delete_text($locator)"
.PP
Delete text in elements where contenteditable=\*(L"true\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See WWW::Selenium for \s-1API\s0 documentation.
See Test::WWW::WebKit for a replacement for Test::WWW::Selenium.
See Test::WWW::WebKit::Catalyst for a replacement for Test::WWW::Selenium::Catalyst.
.PP
The current development version can be found in the git repository at:
https://github.com/niner/WWW\-WebKit
.SH "AUTHOR"
.IX Header "AUTHOR"
Stefan Seifert, <nine@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2011 by Stefan Seifert
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.12.3 or,
at your option, any later version of Perl 5 you may have available.
